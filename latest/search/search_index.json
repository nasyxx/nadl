{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>nadl</code>","text":"<p>Nasy's JAX/FLAX deep learning toolkit.</p>"},{"location":"api/","title":"API","text":"<p>Python \u2661 Nasy.</p> <pre><code>|             *         *\n|                  .                .\n|           .                              \u767b\n|     *                      ,\n|                   .                      \u81f3\n|\n|                               *          \u6056\n|          |\\___/|\n|          )    -(             .           \u8056 \u00b7\n|         =\\ -   /=\n|           )===(       *\n|          /   - \\\n|          |-    |\n|         /   -   \\     0.|.0\n|  NASY___\\__( (__/_____(\\=/)__+1s____________\n|  ______|____) )______|______|______|______|_\n|  ___|______( (____|______|______|______|____\n|  ______|____\\_|______|______|______|______|_\n|  ___|______|______|______|______|______|____\n|  ______|______|______|______|______|______|_\n|  ___|______|______|______|______|______|____\n</code></pre> <p>author   : Nasy https://nasy.moe date     : Nov 29, 2023 email    : Nasy nasyxx+python@gmail.com filename : init.py project  : nadl license  : GPL-3.0+</p> <p>NADL</p>"},{"location":"api/#nadl.DState","title":"<code>DState</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Dataloader state.</p> Source code in <code>nadl/data.py</code> <pre><code>class DState(NamedTuple):\n  \"\"\"Dataloader state.\"\"\"\n\n  idx: jax.Array\n  pad: int | None = None\n</code></pre>"},{"location":"api/#nadl.IdxDataloader","title":"<code>IdxDataloader</code>","text":"<p>             Bases: <code>Module</code></p> <p>Simple index dataloader.</p> <p>Provide indexes only for datasets.</p> Source code in <code>nadl/data.py</code> <pre><code>class IdxDataloader(eqx.Module):\n  \"\"\"Simple index dataloader.\n\n  Provide indexes only for datasets.\n  \"\"\"\n\n  length: int\n  key: Keys\n  batch_size: int = 1\n  shuffle: bool = False\n  drop_last: bool = False\n  auto_pad: bool = True\n\n  def __init__(\n    self,\n    length: int,\n    batch_size: int = 1,\n    shuffle: bool = False,\n    drop_last: bool = False,\n    auto_pad: bool = False,\n    key: jax.Array | None = None,\n  ) -&gt; None:\n    \"\"\"Initiate the dataloader.\"\"\"\n    self.length = length\n    self.batch_size = batch_size\n    self.shuffle = shuffle\n    self.drop_last = drop_last\n    self.auto_pad = auto_pad\n    self.key = Keys.from_int_or_key(key or 42)\n\n  def __call__(self, ki: int) -&gt; Iterator[DState]:\n    \"\"\"Get the indexes.\"\"\"\n    idxes = (\n      jax.random.permutation(self.key(ki)[1], self.length)\n      if self.shuffle\n      else jnp.arange(self.length)\n    )\n    if self.drop_last:\n      length = self.length - self.length % self.batch_size\n      idxes = idxes[:length]\n      pad = 0\n\n    pad = self.batch_size - len(idxes) % self.batch_size\n    if 0 &lt; pad &lt; self.batch_size:\n      idxes = jnp.r_[idxes, jnp.zeros(pad, idxes.dtype)]\n    idxes = idxes.reshape(-1, self.batch_size)\n\n    for i, idx in enumerate(idxes):\n      if pad and i &gt;= idxes.shape[0] - 1:\n        if self.auto_pad:\n          yield DState(idx, pad)\n        else:\n          yield DState(idx[:-pad], 0)\n      else:\n        yield DState(idx, 0)\n</code></pre>"},{"location":"api/#nadl.IdxDataloader.__call__","title":"<code>__call__(ki)</code>","text":"<p>Get the indexes.</p> Source code in <code>nadl/data.py</code> <pre><code>def __call__(self, ki: int) -&gt; Iterator[DState]:\n  \"\"\"Get the indexes.\"\"\"\n  idxes = (\n    jax.random.permutation(self.key(ki)[1], self.length)\n    if self.shuffle\n    else jnp.arange(self.length)\n  )\n  if self.drop_last:\n    length = self.length - self.length % self.batch_size\n    idxes = idxes[:length]\n    pad = 0\n\n  pad = self.batch_size - len(idxes) % self.batch_size\n  if 0 &lt; pad &lt; self.batch_size:\n    idxes = jnp.r_[idxes, jnp.zeros(pad, idxes.dtype)]\n  idxes = idxes.reshape(-1, self.batch_size)\n\n  for i, idx in enumerate(idxes):\n    if pad and i &gt;= idxes.shape[0] - 1:\n      if self.auto_pad:\n        yield DState(idx, pad)\n      else:\n        yield DState(idx[:-pad], 0)\n    else:\n      yield DState(idx, 0)\n</code></pre>"},{"location":"api/#nadl.IdxDataloader.__init__","title":"<code>__init__(length, batch_size=1, shuffle=False, drop_last=False, auto_pad=False, key=None)</code>","text":"<p>Initiate the dataloader.</p> Source code in <code>nadl/data.py</code> <pre><code>def __init__(\n  self,\n  length: int,\n  batch_size: int = 1,\n  shuffle: bool = False,\n  drop_last: bool = False,\n  auto_pad: bool = False,\n  key: jax.Array | None = None,\n) -&gt; None:\n  \"\"\"Initiate the dataloader.\"\"\"\n  self.length = length\n  self.batch_size = batch_size\n  self.shuffle = shuffle\n  self.drop_last = drop_last\n  self.auto_pad = auto_pad\n  self.key = Keys.from_int_or_key(key or 42)\n</code></pre>"},{"location":"api/#nadl.Keys","title":"<code>Keys</code>","text":"<p>             Bases: <code>Module</code></p> <p>JAX random key sequence.</p> Source code in <code>nadl/keys.py</code> <pre><code>class Keys(Module):\n  \"\"\"JAX random key sequence.\"\"\"\n\n  key: jax.Array\n  subkeys: deque[jax.Array]\n  init_key: jax.Array\n  step: jax.Array = field(default_factory=lambda: jax.numpy.array(0))\n\n  @property\n  def state(self) -&gt; tuple[jax.Array, Sequence[jax.Array], jax.Array]:\n    \"\"\"Get state.\"\"\"\n    return self.key, self.subkeys, self.step\n\n  @classmethod\n  def from_int_or_key(cls: type[\"Keys\"], key: jax.Array | int) -&gt; \"Keys\":\n    \"\"\"Convert int or key to Keys.\"\"\"\n    if isinstance(key, int):\n      return cls(key := jax.random.key(key), deque(), key)\n    return cls(key, deque(), key)\n\n  @classmethod\n  def from_state(\n    cls: type[\"Keys\"], key: jax.Array, subkeys: Sequence[jax.Array], step: jax.Array\n  ) -&gt; \"Keys\":\n    \"\"\"Convert state to Keys.\"\"\"\n    return cls(key, deque(subkeys), step)\n\n  def reverse(self, num: int) -&gt; \"Keys\":\n    \"\"\"Reverse the keys.\"\"\"\n    while (num := num - 1) &gt;= 0:\n      if self.subkeys:\n        self.subkeys.append(jax.random.fold_in(self.subkeys[-1], 0))\n      else:\n        self.subkeys.append(jax.random.fold_in(self.key, 0))\n    return self\n\n  def next_key(self) -&gt; tuple[\"Keys\", jax.Array]:\n    \"\"\"Get next key.\"\"\"\n    if not self.subkeys:\n      self.reverse(1)\n    key = self.subkeys.popleft()\n    return self.from_state(key, self.subkeys, self.step + 1), key\n\n  def take(self, num: int) -&gt; tuple[\"Keys\", tuple[jax.Array, ...]]:\n    \"\"\"Take num keys.\"\"\"\n    self.reverse(max(num - len(self.subkeys), 0))\n    keys = tuple(self.subkeys.popleft() for _ in range(num))\n    return self.from_state(keys[-1], self.subkeys, self.step + num), keys\n\n  def __call__(self, epoch: int | None = None) -&gt; tuple[\"Keys\", jax.Array]:\n    \"\"\"Get keys for epoch.\"\"\"\n    if epoch:\n      if epoch &gt; self.step:\n        keys, ks = self.take((epoch - self.step).item())\n        return keys, ks[-1]\n      key = Keys.from_int_or_key(self.init_key)\n      keys, ks = key.take(epoch)\n      return keys, ks[-1]\n    return self.next_key()\n</code></pre>"},{"location":"api/#nadl.Keys.state","title":"<code>state: tuple[jax.Array, Sequence[jax.Array], jax.Array]</code>  <code>property</code>","text":"<p>Get state.</p>"},{"location":"api/#nadl.Keys.__call__","title":"<code>__call__(epoch=None)</code>","text":"<p>Get keys for epoch.</p> Source code in <code>nadl/keys.py</code> <pre><code>def __call__(self, epoch: int | None = None) -&gt; tuple[\"Keys\", jax.Array]:\n  \"\"\"Get keys for epoch.\"\"\"\n  if epoch:\n    if epoch &gt; self.step:\n      keys, ks = self.take((epoch - self.step).item())\n      return keys, ks[-1]\n    key = Keys.from_int_or_key(self.init_key)\n    keys, ks = key.take(epoch)\n    return keys, ks[-1]\n  return self.next_key()\n</code></pre>"},{"location":"api/#nadl.Keys.from_int_or_key","title":"<code>from_int_or_key(key)</code>  <code>classmethod</code>","text":"<p>Convert int or key to Keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>@classmethod\ndef from_int_or_key(cls: type[\"Keys\"], key: jax.Array | int) -&gt; \"Keys\":\n  \"\"\"Convert int or key to Keys.\"\"\"\n  if isinstance(key, int):\n    return cls(key := jax.random.key(key), deque(), key)\n  return cls(key, deque(), key)\n</code></pre>"},{"location":"api/#nadl.Keys.from_state","title":"<code>from_state(key, subkeys, step)</code>  <code>classmethod</code>","text":"<p>Convert state to Keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>@classmethod\ndef from_state(\n  cls: type[\"Keys\"], key: jax.Array, subkeys: Sequence[jax.Array], step: jax.Array\n) -&gt; \"Keys\":\n  \"\"\"Convert state to Keys.\"\"\"\n  return cls(key, deque(subkeys), step)\n</code></pre>"},{"location":"api/#nadl.Keys.next_key","title":"<code>next_key()</code>","text":"<p>Get next key.</p> Source code in <code>nadl/keys.py</code> <pre><code>def next_key(self) -&gt; tuple[\"Keys\", jax.Array]:\n  \"\"\"Get next key.\"\"\"\n  if not self.subkeys:\n    self.reverse(1)\n  key = self.subkeys.popleft()\n  return self.from_state(key, self.subkeys, self.step + 1), key\n</code></pre>"},{"location":"api/#nadl.Keys.reverse","title":"<code>reverse(num)</code>","text":"<p>Reverse the keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>def reverse(self, num: int) -&gt; \"Keys\":\n  \"\"\"Reverse the keys.\"\"\"\n  while (num := num - 1) &gt;= 0:\n    if self.subkeys:\n      self.subkeys.append(jax.random.fold_in(self.subkeys[-1], 0))\n    else:\n      self.subkeys.append(jax.random.fold_in(self.key, 0))\n  return self\n</code></pre>"},{"location":"api/#nadl.Keys.take","title":"<code>take(num)</code>","text":"<p>Take num keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>def take(self, num: int) -&gt; tuple[\"Keys\", tuple[jax.Array, ...]]:\n  \"\"\"Take num keys.\"\"\"\n  self.reverse(max(num - len(self.subkeys), 0))\n  keys = tuple(self.subkeys.popleft() for _ in range(num))\n  return self.from_state(keys[-1], self.subkeys, self.step + num), keys\n</code></pre>"},{"location":"api/#nadl.PG","title":"<code>PG</code>","text":"<p>             Bases: <code>Module</code></p> <p>Progress.</p> Source code in <code>nadl/loops.py</code> <pre><code>class PG(Module):\n  \"\"\"Progress.\"\"\"\n\n  pg: Progress\n  console: Console\n  tasks: dict[Hashable, TaskID]\n\n  @classmethod\n  def init_progress(\n    cls: type[Self],\n    pg: Progress | None = None,\n    console: Console | None = None,\n    total: bool = True,\n    bar_width: int | None = 20,\n    extra_columns: tuple[ProgressColumn, ...] = (),\n    show_progress: bool = True,\n    theme: Theme | None = None,\n  ) -&gt; Self:\n    \"\"\"Init progress bar.\"\"\"\n    if console is None:\n      console = Console(theme=theme or DEF_LIGHT_THEME)\n    if pg is None:\n      pg = Progress(\n        TextColumn(\n          \"{task.description}\" + \" - {task.completed}/{task.total}\" if total else \"\"\n        ),\n        TimeRemainingColumn(),\n        TimeElapsedColumn(),\n        BarColumn(bar_width),\n        console=console,\n        disable=not show_progress,\n      )\n    pg.columns += extra_columns\n    return cls(pg, console, {})\n\n  def add_columns(self, columns: tuple[ProgressColumn, ...]) -&gt; Self:\n    \"\"\"Add columns.\"\"\"\n    self.pg.columns += columns\n    return self\n\n  def add_task(\n    self,\n    description: str,\n    start: bool = True,\n    total: float | None = 100,\n    completed: int = 0,\n    visible: bool = True,\n    **fileds: Any,  # noqa: ANN401\n  ) -&gt; TaskID:\n    \"\"\"Add task.\"\"\"\n    task = self.pg.add_task(\n      description,\n      start=start,\n      total=total,\n      completed=completed,\n      visible=visible,\n      **fileds,\n    )\n    self.tasks[description] = task\n    return task\n\n  def advance(self, task: TaskID, advance: float = 1) -&gt; None:\n    \"\"\"Advance task.\"\"\"\n    self.pg.advance(task, advance=advance)\n\n  def __enter__(self) -&gt; Progress:\n    \"\"\"Enter.\"\"\"\n    return self.pg.__enter__()\n\n  def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n  ) -&gt; None:\n    \"\"\"Exit.\"\"\"\n    self.pg.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#nadl.PG.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __enter__(self) -&gt; Progress:\n  \"\"\"Enter.\"\"\"\n  return self.pg.__enter__()\n</code></pre>"},{"location":"api/#nadl.PG.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __exit__(\n  self,\n  exc_type: type[BaseException] | None,\n  exc_val: BaseException | None,\n  exc_tb: TracebackType | None,\n) -&gt; None:\n  \"\"\"Exit.\"\"\"\n  self.pg.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#nadl.PG.add_columns","title":"<code>add_columns(columns)</code>","text":"<p>Add columns.</p> Source code in <code>nadl/loops.py</code> <pre><code>def add_columns(self, columns: tuple[ProgressColumn, ...]) -&gt; Self:\n  \"\"\"Add columns.\"\"\"\n  self.pg.columns += columns\n  return self\n</code></pre>"},{"location":"api/#nadl.PG.add_task","title":"<code>add_task(description, start=True, total=100, completed=0, visible=True, **fileds)</code>","text":"<p>Add task.</p> Source code in <code>nadl/loops.py</code> <pre><code>def add_task(\n  self,\n  description: str,\n  start: bool = True,\n  total: float | None = 100,\n  completed: int = 0,\n  visible: bool = True,\n  **fileds: Any,  # noqa: ANN401\n) -&gt; TaskID:\n  \"\"\"Add task.\"\"\"\n  task = self.pg.add_task(\n    description,\n    start=start,\n    total=total,\n    completed=completed,\n    visible=visible,\n    **fileds,\n  )\n  self.tasks[description] = task\n  return task\n</code></pre>"},{"location":"api/#nadl.PG.advance","title":"<code>advance(task, advance=1)</code>","text":"<p>Advance task.</p> Source code in <code>nadl/loops.py</code> <pre><code>def advance(self, task: TaskID, advance: float = 1) -&gt; None:\n  \"\"\"Advance task.\"\"\"\n  self.pg.advance(task, advance=advance)\n</code></pre>"},{"location":"api/#nadl.PG.init_progress","title":"<code>init_progress(pg=None, console=None, total=True, bar_width=20, extra_columns=(), show_progress=True, theme=None)</code>  <code>classmethod</code>","text":"<p>Init progress bar.</p> Source code in <code>nadl/loops.py</code> <pre><code>@classmethod\ndef init_progress(\n  cls: type[Self],\n  pg: Progress | None = None,\n  console: Console | None = None,\n  total: bool = True,\n  bar_width: int | None = 20,\n  extra_columns: tuple[ProgressColumn, ...] = (),\n  show_progress: bool = True,\n  theme: Theme | None = None,\n) -&gt; Self:\n  \"\"\"Init progress bar.\"\"\"\n  if console is None:\n    console = Console(theme=theme or DEF_LIGHT_THEME)\n  if pg is None:\n    pg = Progress(\n      TextColumn(\n        \"{task.description}\" + \" - {task.completed}/{task.total}\" if total else \"\"\n      ),\n      TimeRemainingColumn(),\n      TimeElapsedColumn(),\n      BarColumn(bar_width),\n      console=console,\n      disable=not show_progress,\n    )\n  pg.columns += extra_columns\n  return cls(pg, console, {})\n</code></pre>"},{"location":"api/#nadl.classit","title":"<code>classit(x, method='sigmoid', threshold=0.5)</code>","text":"<p>Classify the array.</p> Source code in <code>nadl/utils.py</code> <pre><code>def classit(\n  x: jax.Array,\n  method: Literal[None, \"sigmoid\", \"softmax\", \"threshold\"] = \"sigmoid\",\n  threshold: float = 0.5,\n) -&gt; jax.Array:\n  \"\"\"Classify the array.\"\"\"\n  match method:\n    case \"sigmoid\":\n      return jax.nn.sigmoid(x) &gt; threshold\n    case \"softmax\":\n      x = jax.nn.softmax(x)\n      return jnp.argmax(x, axis=-1, keepdims=True)\n    case \"threshold\":\n      return x &gt; threshold\n    case _:\n      raise ValueError(f\"Unknown method {method}\")\n</code></pre>"},{"location":"api/#nadl.dice_coef","title":"<code>dice_coef(y_true, y_pred, eps=1e-08)</code>","text":"<p>Compute dice coefficient.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def dice_coef(y_true: jax.Array, y_pred: jax.Array, eps: float = 1e-8) -&gt; jax.Array:\n  \"\"\"Compute dice coefficient.\"\"\"\n  y_true = jnp.asarray(y_true)\n  y_pred = jnp.asarray(y_pred)\n\n  intersection = jnp.sum(y_true * y_pred)\n  union = jnp.sum(y_true) + jnp.sum(y_pred)\n\n  return (2.0 * intersection) / (union + eps)\n</code></pre>"},{"location":"api/#nadl.identity_scaler","title":"<code>identity_scaler(arr, axis=0)</code>","text":"<p>Get identity scaler.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def identity_scaler(arr: jax.Array, axis: int = 0) -&gt; SCALER:\n  \"\"\"Get identity scaler.\"\"\"\n  del arr, axis\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    return x\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.iou_coef","title":"<code>iou_coef(y_true, y_pred, eps=1e-08)</code>","text":"<p>Compute intersection over union.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def iou_coef(y_true: jax.Array, y_pred: jax.Array, eps: float = 1e-8) -&gt; jax.Array:\n  \"\"\"Compute intersection over union.\"\"\"\n  y_true = jnp.asarray(y_true)\n  y_pred = jnp.asarray(y_pred)\n\n  intersection = jnp.sum(y_true * y_pred)\n  union = jnp.sum(y_true) + jnp.sum(y_pred) - intersection\n\n  return intersection / (union + eps)\n</code></pre>"},{"location":"api/#nadl.min_max_scaler","title":"<code>min_max_scaler(arr, axis=0)</code>","text":"<p>Get min max scaler.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def min_max_scaler(arr: jax.Array, axis: int = 0) -&gt; SCALER:\n  \"\"\"Get min max scaler.\"\"\"\n  min_, max_ = arr.min(axis=axis, keepdims=True), arr.max(axis=axis, keepdims=True)\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    return (x - min_) / (max_ - min_)\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.normalizer","title":"<code>normalizer(arr, axis=0, norm='l2')</code>","text":"<p>Get normalizer.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def normalizer(\n  arr: jax.Array, axis: int = 0, norm: Literal[\"l1\", \"l2\", \"max\"] = \"l2\"\n) -&gt; SCALER:\n  \"\"\"Get normalizer.\"\"\"\n  match norm:\n    case \"l2\":\n      norm_value = jnp.sqrt(jnp.sum(jnp.square(arr), axis=axis, keepdims=True))\n    case \"l1\":\n      norm_value = jnp.sum(jnp.abs(arr), axis=axis, keepdims=True)\n    case \"max\":\n      norm_value = jnp.max(jnp.abs(arr), axis=axis, keepdims=True)\n    case _:\n      raise ValueError(\"norm should be 'l1', 'l2', or 'max'\")\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    max_val = jnp.maximum(norm_value, jnp.finfo(x.dtype).tiny)  # Avoid division by zero\n    return x / max_val\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.rle","title":"<code>rle(x, shift=1)</code>","text":"<p>Run length encoding.</p> Source code in <code>nadl/utils.py</code> <pre><code>def rle(x: jax.Array, shift: int = 1) -&gt; str:\n  \"\"\"Run length encoding.\"\"\"\n  return \" \".join(map(str, rle_array(x, shift)))\n</code></pre>"},{"location":"api/#nadl.rle_array","title":"<code>rle_array(x, shift=1)</code>","text":"<p>Run length encoding array.</p> Source code in <code>nadl/utils.py</code> <pre><code>def rle_array(x: jax.Array, shift: int = 1) -&gt; jax.Array:\n  \"\"\"Run length encoding array.\"\"\"\n  x = x.flatten()\n  x = jnp.pad(x, (1, 1), mode=\"constant\")\n  x = jnp.argwhere(x[1:] != x[:-1]).flatten() + shift\n  return x.at[1::2].add(-x[::2])\n</code></pre>"},{"location":"api/#nadl.select_scaler","title":"<code>select_scaler(method='minmax', axis=0)</code>","text":"<p>Get scaler function.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def select_scaler(\n  method: Literal[\"id\", \"minmax\", \"std\", \"l2_norm\", \"l1_norm\", \"max_norm\"] = \"minmax\",\n  axis: int = 0,\n) -&gt; Callable[[jax.Array], SCALER]:\n  \"\"\"Get scaler function.\"\"\"\n  match method:\n    case \"id\":\n      return partial(identity_scaler, axis=axis)\n    case \"minmax\":\n      return partial(min_max_scaler, axis=axis)\n    case \"std\":\n      return partial(standard_scaler, axis=axis)\n    case \"l2_norm\":\n      return partial(normalizer, norm=\"l2\", axis=axis)\n    case \"l1_norm\":\n      return partial(normalizer, norm=\"l1\", axis=axis)\n    case \"max_norm\":\n      return partial(normalizer, norm=\"max\", axis=axis)\n    case _:\n      raise ValueError(f\"Unknown scaler method {method}\")\n</code></pre>"},{"location":"api/#nadl.standard_scaler","title":"<code>standard_scaler(arr, axis=0)</code>","text":"<p>Get standard scaler.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def standard_scaler(arr: jax.Array, axis: int = 0) -&gt; SCALER:\n  \"\"\"Get standard scaler.\"\"\"\n  mean, std = arr.mean(axis=axis, keepdims=True), arr.std(axis=axis, keepdims=True)\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    return (x - mean) / std\n\n  return scaler\n</code></pre>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>nadl</code>","text":"<p>Nasy's JAX/FLAX deep learning toolkit.</p>"},{"location":"api/","title":"API","text":"<p>Python \u2661 Nasy.</p> <pre><code>|             *         *\n|                  .                .\n|           .                              \u767b\n|     *                      ,\n|                   .                      \u81f3\n|\n|                               *          \u6056\n|          |\\___/|\n|          )    -(             .           \u8056 \u00b7\n|         =\\ -   /=\n|           )===(       *\n|          /   - \\\n|          |-    |\n|         /   -   \\     0.|.0\n|  NASY___\\__( (__/_____(\\=/)__+1s____________\n|  ______|____) )______|______|______|______|_\n|  ___|______( (____|______|______|______|____\n|  ______|____\\_|______|______|______|______|_\n|  ___|______|______|______|______|______|____\n|  ______|______|______|______|______|______|_\n|  ___|______|______|______|______|______|____\n</code></pre> <p>author   : Nasy https://nasy.moe date     : Nov 29, 2023 email    : Nasy nasyxx+python@gmail.com filename : init.py project  : nadl license  : GPL-3.0+</p> <p>NADL</p>"},{"location":"api/#nadl.Accuracy","title":"<code>Accuracy</code>","text":"<p>               Bases: <code>Metric</code></p> <p>Accuracy.</p> Source code in <code>nadl/metrics.py</code> <pre><code>class Accuracy(Metric):\n  \"\"\"Accuracy.\"\"\"\n\n  labels: Int[Array, \"...\"]\n  preds: Int[Array, \"...\"]\n  name: str = \"accuracy\"\n\n  @classmethod\n  def empty(cls, name: str = \"accuracy\") -&gt; Self:\n    \"\"\"Empty.\"\"\"\n    return cls(labels=jnp.asarray([jnp.nan]), preds=jnp.asarray([jnp.nan]), name=name)\n\n  def compute(self) -&gt; Array:\n    \"\"\"Compute.\"\"\"\n    return jnp.nanmean(self.labels == self.preds, axis=-1)\n</code></pre>"},{"location":"api/#nadl.Accuracy.compute","title":"<code>compute()</code>","text":"<p>Compute.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def compute(self) -&gt; Array:\n  \"\"\"Compute.\"\"\"\n  return jnp.nanmean(self.labels == self.preds, axis=-1)\n</code></pre>"},{"location":"api/#nadl.Accuracy.empty","title":"<code>empty(name='accuracy')</code>  <code>classmethod</code>","text":"<p>Empty.</p> Source code in <code>nadl/metrics.py</code> <pre><code>@classmethod\ndef empty(cls, name: str = \"accuracy\") -&gt; Self:\n  \"\"\"Empty.\"\"\"\n  return cls(labels=jnp.asarray([jnp.nan]), preds=jnp.asarray([jnp.nan]), name=name)\n</code></pre>"},{"location":"api/#nadl.BaseTrainState","title":"<code>BaseTrainState</code>","text":"<p>               Bases: <code>Module</code></p> <p>Train state.</p> Source code in <code>nadl/states.py</code> <pre><code>class BaseTrainState[T, M](eqx.Module):\n  \"\"\"Train state.\"\"\"\n\n  model: M\n  tx: optax.GradientTransformation\n  opt_state: optax.OptState\n  loss: jax.Array\n  step: jax.Array\n  conf: T\n\n  @classmethod\n  @abstractmethod\n  def create[**P](\n    cls: type[BaseTrainState[T, M]], *args: P.args, **kwds: P.kwargs\n  ) -&gt; BaseTrainState[T, M]:\n    \"\"\"Create state.\"\"\"\n    raise NotImplementedError\n\n  def apply_grads(self, loss: jax.Array, grads: eqx.Module) -&gt; BaseTrainState[T, M]:\n    \"\"\"Apply gradients.\"\"\"\n    updates, opt_state = self.tx.update(\n      cast(optax.Updates, grads), self.opt_state, params=cast(optax.Params, self.model)\n    )\n    model = eqx.apply_updates(self.model, updates)\n    return eqx.tree_at(\n      lambda x: (x.model, x.opt_state, x.loss, x.step),\n      self,\n      (model, opt_state, loss, self.step + 1),\n    )\n</code></pre>"},{"location":"api/#nadl.BaseTrainState.apply_grads","title":"<code>apply_grads(loss, grads)</code>","text":"<p>Apply gradients.</p> Source code in <code>nadl/states.py</code> <pre><code>def apply_grads(self, loss: jax.Array, grads: eqx.Module) -&gt; BaseTrainState[T, M]:\n  \"\"\"Apply gradients.\"\"\"\n  updates, opt_state = self.tx.update(\n    cast(optax.Updates, grads), self.opt_state, params=cast(optax.Params, self.model)\n  )\n  model = eqx.apply_updates(self.model, updates)\n  return eqx.tree_at(\n    lambda x: (x.model, x.opt_state, x.loss, x.step),\n    self,\n    (model, opt_state, loss, self.step + 1),\n  )\n</code></pre>"},{"location":"api/#nadl.BaseTrainState.create","title":"<code>create(*args, **kwds)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create state.</p> Source code in <code>nadl/states.py</code> <pre><code>@classmethod\n@abstractmethod\ndef create[**P](\n  cls: type[BaseTrainState[T, M]], *args: P.args, **kwds: P.kwargs\n) -&gt; BaseTrainState[T, M]:\n  \"\"\"Create state.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"api/#nadl.DState","title":"<code>DState</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Dataloader state.</p> Source code in <code>nadl/data.py</code> <pre><code>class DState[T](NamedTuple):\n  \"\"\"Dataloader state.\"\"\"\n\n  xs: T\n  pad: jax.Array\n  shape: tuple[int, ...]\n  epoch: jax.Array = field(default_factory=lambda: jnp.array(0))\n  step: jax.Array = field(default_factory=lambda: jnp.array(0))\n  name: str | None = None\n</code></pre>"},{"location":"api/#nadl.IdxDataloader","title":"<code>IdxDataloader</code>","text":"<p>               Bases: <code>Module</code></p> <p>Simple index dataloader.</p> Source code in <code>nadl/data.py</code> <pre><code>class IdxDataloader[T](eqx.Module):\n  \"\"\"Simple index dataloader.\"\"\"\n\n  length: int\n  pad: int\n  batch_size: int\n  drop_num: int = 0\n  transform: Callable[[jax.Array], T] = eqx.field(static=True, init=False)\n\n  def __init__(\n    self,\n    length: int,\n    batch_size: int,\n    drop_last: bool = False,\n    transform: Callable[[jax.Array], T] = lambda x: x,\n  ) -&gt; None:\n    \"\"\"Initiate the dataloader.\"\"\"\n    self.length = length\n\n    if drop_last:\n      self.drop_num = self.length % batch_size\n\n    length = length if not drop_last else length - length % batch_size\n    pad = (batch_size - r) % batch_size if (r := length % batch_size) else 0\n    self.pad = pad = pad if pad != batch_size else 0\n\n    self.batch_size = batch_size\n    self.transform = eqx.filter_jit(transform)\n\n  def __call__(self, key: jax.Array | None = None) -&gt; DState[T]:\n    \"\"\"Get the indexes.\"\"\"\n    idxes = jnp.arange(self.length)\n    if key is not None:\n      idxes = jnp.take_along_axis(\n        idxes,\n        # NOTE: Fallback to numpy argsort since it has performance isssue in CPU.\n        # https://github.com/google/jax/issues/10434\n        fallback_argsort(jax.random.uniform(key, (self.length,))),\n        axis=0,\n      )\n    length = self.length if not self.drop_num else self.length - self.drop_num\n\n    idxes = jnp.r_[idxes, jnp.full(self.pad, -1, idxes.dtype)]\n    idxes = idxes[: length + self.pad].reshape(-1, self.batch_size)\n    return DState(\n      self.transform(idxes), jnp.where(idxes == -1, 1, 0).astype(bool), idxes.shape\n    )\n</code></pre>"},{"location":"api/#nadl.IdxDataloader.__call__","title":"<code>__call__(key=None)</code>","text":"<p>Get the indexes.</p> Source code in <code>nadl/data.py</code> <pre><code>def __call__(self, key: jax.Array | None = None) -&gt; DState[T]:\n  \"\"\"Get the indexes.\"\"\"\n  idxes = jnp.arange(self.length)\n  if key is not None:\n    idxes = jnp.take_along_axis(\n      idxes,\n      # NOTE: Fallback to numpy argsort since it has performance isssue in CPU.\n      # https://github.com/google/jax/issues/10434\n      fallback_argsort(jax.random.uniform(key, (self.length,))),\n      axis=0,\n    )\n  length = self.length if not self.drop_num else self.length - self.drop_num\n\n  idxes = jnp.r_[idxes, jnp.full(self.pad, -1, idxes.dtype)]\n  idxes = idxes[: length + self.pad].reshape(-1, self.batch_size)\n  return DState(\n    self.transform(idxes), jnp.where(idxes == -1, 1, 0).astype(bool), idxes.shape\n  )\n</code></pre>"},{"location":"api/#nadl.IdxDataloader.__init__","title":"<code>__init__(length, batch_size, drop_last=False, transform=lambda x: x)</code>","text":"<p>Initiate the dataloader.</p> Source code in <code>nadl/data.py</code> <pre><code>def __init__(\n  self,\n  length: int,\n  batch_size: int,\n  drop_last: bool = False,\n  transform: Callable[[jax.Array], T] = lambda x: x,\n) -&gt; None:\n  \"\"\"Initiate the dataloader.\"\"\"\n  self.length = length\n\n  if drop_last:\n    self.drop_num = self.length % batch_size\n\n  length = length if not drop_last else length - length % batch_size\n  pad = (batch_size - r) % batch_size if (r := length % batch_size) else 0\n  self.pad = pad = pad if pad != batch_size else 0\n\n  self.batch_size = batch_size\n  self.transform = eqx.filter_jit(transform)\n</code></pre>"},{"location":"api/#nadl.Keys","title":"<code>Keys</code>","text":"<p>               Bases: <code>Module</code></p> <p>JAX random key sequence.</p> <p>init_key:  The initial key. keys: The key sequence in cluding the histories. idx: Current key idx in the key sequence.</p> Source code in <code>nadl/keys.py</code> <pre><code>class Keys(Module):\n  \"\"\"JAX random key sequence.\n\n  init_key:  The initial key.\n  keys: The key sequence in cluding the histories.\n  idx: Current key idx in the key sequence.\n  \"\"\"\n\n  init_key: PRNGKeyArray\n  keys: PRNGKeyArray\n  idx: IL = 0\n\n  def __call__(self, epoch: ArrayLike) -&gt; jax.Array:\n    \"\"\"Get keys for epoch.\"\"\"\n    return jax.random.fold_in(self.init_key, epoch)\n\n  def __iter__(self) -&gt; Keys:\n    \"\"\"Iterate the keys.\"\"\"\n    return self\n\n  def __next__(self) -&gt; Keys:\n    \"\"\"Get next key.\"\"\"\n    return self.next_key()\n\n  def __len__(self) -&gt; int:\n    \"\"\"Length of keys.\"\"\"\n    return self.keys.shape[0]\n\n  @property\n  def key(self) -&gt; PRNGKeyArray:\n    \"\"\"Get key.\"\"\"\n    if self.keys.shape[0]:\n      return self.keys[-1]\n    return self(self.idx + 1)\n\n  @property\n  def state(self) -&gt; tuple[PRNGKeyArray, PRNGKeyArray, IL]:\n    \"\"\"Get state.\"\"\"\n    return self.init_key, self.keys, self.idx\n\n  @classmethod\n  def from_int_or_key(cls: type[Keys], key: PRNGKeyArray | int) -&gt; Keys:\n    \"\"\"Convert int or key to Keys.\"\"\"\n    if isinstance(key, int):\n      key = jax.random.key(key)\n    return cls(key, jax.random.fold_in(key, 0).reshape(-1), jnp.asarray(0))\n\n  @classmethod\n  def from_state(\n    cls: type[Keys], key: PRNGKeyArray, keys: PRNGKeyArray, idx: IL\n  ) -&gt; Keys:\n    \"\"\"Convert state to Keys.\"\"\"\n    return cls(key, keys, idx)\n\n  def reserve(self, num: int | jax.Array) -&gt; Keys:\n    \"\"\"Reverse the keys.\"\"\"\n    return tree_at(\n      lambda x: x.keys,\n      self,\n      jax.vmap(self)(jnp.arange(jnp.maximum(num, len(self)))),\n    )\n\n  def next_key(self) -&gt; Keys:\n    \"\"\"Get next key.\"\"\"\n    return tree_at(lambda k: k.idx, self, self.idx + 1)\n\n  def take(self, num: int) -&gt; PRNGKeyArray:\n    \"\"\"Take num keys.\"\"\"\n    return jax.vmap(self)(jnp.arange(num)) if num &gt; len(self) else self.keys[-num:]\n</code></pre>"},{"location":"api/#nadl.Keys.key","title":"<code>key: PRNGKeyArray</code>  <code>property</code>","text":"<p>Get key.</p>"},{"location":"api/#nadl.Keys.state","title":"<code>state: tuple[PRNGKeyArray, PRNGKeyArray, IL]</code>  <code>property</code>","text":"<p>Get state.</p>"},{"location":"api/#nadl.Keys.__call__","title":"<code>__call__(epoch)</code>","text":"<p>Get keys for epoch.</p> Source code in <code>nadl/keys.py</code> <pre><code>def __call__(self, epoch: ArrayLike) -&gt; jax.Array:\n  \"\"\"Get keys for epoch.\"\"\"\n  return jax.random.fold_in(self.init_key, epoch)\n</code></pre>"},{"location":"api/#nadl.Keys.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate the keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>def __iter__(self) -&gt; Keys:\n  \"\"\"Iterate the keys.\"\"\"\n  return self\n</code></pre>"},{"location":"api/#nadl.Keys.__len__","title":"<code>__len__()</code>","text":"<p>Length of keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>def __len__(self) -&gt; int:\n  \"\"\"Length of keys.\"\"\"\n  return self.keys.shape[0]\n</code></pre>"},{"location":"api/#nadl.Keys.__next__","title":"<code>__next__()</code>","text":"<p>Get next key.</p> Source code in <code>nadl/keys.py</code> <pre><code>def __next__(self) -&gt; Keys:\n  \"\"\"Get next key.\"\"\"\n  return self.next_key()\n</code></pre>"},{"location":"api/#nadl.Keys.from_int_or_key","title":"<code>from_int_or_key(key)</code>  <code>classmethod</code>","text":"<p>Convert int or key to Keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>@classmethod\ndef from_int_or_key(cls: type[Keys], key: PRNGKeyArray | int) -&gt; Keys:\n  \"\"\"Convert int or key to Keys.\"\"\"\n  if isinstance(key, int):\n    key = jax.random.key(key)\n  return cls(key, jax.random.fold_in(key, 0).reshape(-1), jnp.asarray(0))\n</code></pre>"},{"location":"api/#nadl.Keys.from_state","title":"<code>from_state(key, keys, idx)</code>  <code>classmethod</code>","text":"<p>Convert state to Keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>@classmethod\ndef from_state(\n  cls: type[Keys], key: PRNGKeyArray, keys: PRNGKeyArray, idx: IL\n) -&gt; Keys:\n  \"\"\"Convert state to Keys.\"\"\"\n  return cls(key, keys, idx)\n</code></pre>"},{"location":"api/#nadl.Keys.next_key","title":"<code>next_key()</code>","text":"<p>Get next key.</p> Source code in <code>nadl/keys.py</code> <pre><code>def next_key(self) -&gt; Keys:\n  \"\"\"Get next key.\"\"\"\n  return tree_at(lambda k: k.idx, self, self.idx + 1)\n</code></pre>"},{"location":"api/#nadl.Keys.reserve","title":"<code>reserve(num)</code>","text":"<p>Reverse the keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>def reserve(self, num: int | jax.Array) -&gt; Keys:\n  \"\"\"Reverse the keys.\"\"\"\n  return tree_at(\n    lambda x: x.keys,\n    self,\n    jax.vmap(self)(jnp.arange(jnp.maximum(num, len(self)))),\n  )\n</code></pre>"},{"location":"api/#nadl.Keys.take","title":"<code>take(num)</code>","text":"<p>Take num keys.</p> Source code in <code>nadl/keys.py</code> <pre><code>def take(self, num: int) -&gt; PRNGKeyArray:\n  \"\"\"Take num keys.\"\"\"\n  return jax.vmap(self)(jnp.arange(num)) if num &gt; len(self) else self.keys[-num:]\n</code></pre>"},{"location":"api/#nadl.Metric","title":"<code>Metric</code>","text":"<p>               Bases: <code>Module</code></p> <p>Base Metric.</p> Source code in <code>nadl/metrics.py</code> <pre><code>class Metric[**P, T](Module):\n  \"\"\"Base Metric.\"\"\"\n\n  name: AbstractVar[str | None]\n\n  def __post_init__(self) -&gt; None:\n    \"\"\"Post init.\"\"\"\n    for k, v in self.__dict__.items():\n      if isinstance(v, Array):\n        self.__dict__[k] = convert(v)\n\n  def __check_init__(self) -&gt; None:  # noqa: PLW3201\n    \"\"\"Check init.\"\"\"\n    arrs = all_array(self)\n    if arrs and (not tree_equal(*jax.tree.map(lambda x: jnp.shape(x)[0], arrs))):\n      raise ValueError(\"All metrics should have the same length in first dim.\")\n\n  @classmethod\n  def merge(cls, *metrics: Self) -&gt; Self:\n    \"\"\"Merge all metrics.\"\"\"\n    _, s2 = partition(metrics, is_array)\n    if not tree_equal(*s2):\n      raise ValueError(\"All metrics should have the same non-array values.\")\n    return filter_concat(metrics)\n\n  def __add__(self, value: Self) -&gt; Self:\n    \"\"\"Add.\"\"\"\n    return self.merge(self, value)\n\n  def __or__(self, value: Self) -&gt; Self:\n    \"\"\"Or.\"\"\"\n    return combine(self, value)\n\n  @classmethod\n  def empty(cls, *args: P.args, **kwds: P.kwargs) -&gt; Self:  # noqa: ARG003\n    \"\"\"Empty.\"\"\"\n    return cls(dict.fromkeys(cls.__dataclass_fields__))  # type: ignore\n\n  def compute(self) -&gt; T:\n    \"\"\"Compute.\"\"\"\n    raise NotImplementedError\n\n  def __getitem__(self, idx: int | slice | Int[ArrayLike, \"...\"]) -&gt; Self:\n    \"\"\"Get item.\"\"\"\n    return jax.tree.map(\n      lambda x: x[idx] if is_array(x) else x,\n      self,\n    )\n\n  def show(self) -&gt; str:\n    \"\"\"Show.\"\"\"\n    return tree_pformat(self, short_arrays=False)\n</code></pre>"},{"location":"api/#nadl.Metric.__add__","title":"<code>__add__(value)</code>","text":"<p>Add.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def __add__(self, value: Self) -&gt; Self:\n  \"\"\"Add.\"\"\"\n  return self.merge(self, value)\n</code></pre>"},{"location":"api/#nadl.Metric.__check_init__","title":"<code>__check_init__()</code>","text":"<p>Check init.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def __check_init__(self) -&gt; None:  # noqa: PLW3201\n  \"\"\"Check init.\"\"\"\n  arrs = all_array(self)\n  if arrs and (not tree_equal(*jax.tree.map(lambda x: jnp.shape(x)[0], arrs))):\n    raise ValueError(\"All metrics should have the same length in first dim.\")\n</code></pre>"},{"location":"api/#nadl.Metric.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Get item.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def __getitem__(self, idx: int | slice | Int[ArrayLike, \"...\"]) -&gt; Self:\n  \"\"\"Get item.\"\"\"\n  return jax.tree.map(\n    lambda x: x[idx] if is_array(x) else x,\n    self,\n  )\n</code></pre>"},{"location":"api/#nadl.Metric.__or__","title":"<code>__or__(value)</code>","text":"<p>Or.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def __or__(self, value: Self) -&gt; Self:\n  \"\"\"Or.\"\"\"\n  return combine(self, value)\n</code></pre>"},{"location":"api/#nadl.Metric.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post init.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def __post_init__(self) -&gt; None:\n  \"\"\"Post init.\"\"\"\n  for k, v in self.__dict__.items():\n    if isinstance(v, Array):\n      self.__dict__[k] = convert(v)\n</code></pre>"},{"location":"api/#nadl.Metric.compute","title":"<code>compute()</code>","text":"<p>Compute.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def compute(self) -&gt; T:\n  \"\"\"Compute.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"api/#nadl.Metric.empty","title":"<code>empty(*args, **kwds)</code>  <code>classmethod</code>","text":"<p>Empty.</p> Source code in <code>nadl/metrics.py</code> <pre><code>@classmethod\ndef empty(cls, *args: P.args, **kwds: P.kwargs) -&gt; Self:  # noqa: ARG003\n  \"\"\"Empty.\"\"\"\n  return cls(dict.fromkeys(cls.__dataclass_fields__))  # type: ignore\n</code></pre>"},{"location":"api/#nadl.Metric.merge","title":"<code>merge(*metrics)</code>  <code>classmethod</code>","text":"<p>Merge all metrics.</p> Source code in <code>nadl/metrics.py</code> <pre><code>@classmethod\ndef merge(cls, *metrics: Self) -&gt; Self:\n  \"\"\"Merge all metrics.\"\"\"\n  _, s2 = partition(metrics, is_array)\n  if not tree_equal(*s2):\n    raise ValueError(\"All metrics should have the same non-array values.\")\n  return filter_concat(metrics)\n</code></pre>"},{"location":"api/#nadl.Metric.show","title":"<code>show()</code>","text":"<p>Show.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def show(self) -&gt; str:\n  \"\"\"Show.\"\"\"\n  return tree_pformat(self, short_arrays=False)\n</code></pre>"},{"location":"api/#nadl.PG","title":"<code>PG</code>","text":"<p>               Bases: <code>Module</code></p> <p>Progress.</p> Source code in <code>nadl/loops.py</code> <pre><code>class PG(Module):\n  \"\"\"Progress.\"\"\"\n\n  pg: Progress\n  console: Console\n  tasks: dict[Hashable, TaskID]\n\n  @classmethod\n  def init_progress(\n    cls: type[Self],\n    pg: Progress | None = None,\n    console: Console | None = None,\n    total: bool = True,\n    bar_width: int | None = 20,\n    extra_columns: tuple[ProgressColumn, ...] = (),\n    show_progress: bool = True,\n    theme: Theme | None = None,\n  ) -&gt; Self:\n    \"\"\"Init progress bar.\"\"\"\n    if console is None:\n      console = Console(theme=theme or DEF_LIGHT_THEME)\n    if pg is None:\n      pg = Progress(\n        TextColumn(\n          \"{task.description}\" + \" - {task.completed}/{task.total}\" if total else \"\"\n        ),\n        TimeRemainingColumn(),\n        TimeElapsedColumn(),\n        BarColumn(bar_width),\n        console=console,\n        disable=not show_progress,\n      )\n    pg.columns += extra_columns\n    return cls(pg, console, {})\n\n  def add_columns(self, columns: tuple[ProgressColumn, ...]) -&gt; Self:\n    \"\"\"Add columns.\"\"\"\n    self.pg.columns += columns\n    return self\n\n  def add_task(\n    self,\n    description: str,\n    start: bool = True,\n    total: float | None = 100,\n    completed: int = 0,\n    visible: bool = True,\n    **fileds: Any,  # noqa: ANN401\n  ) -&gt; TaskID:\n    \"\"\"Add task.\"\"\"\n    task = self.pg.add_task(\n      description,\n      start=start,\n      total=total,\n      completed=completed,\n      visible=visible,\n      **fileds,\n    )\n    self.tasks[description] = task\n    return task\n\n  def advance(self, task: TaskID, advance: float = 1) -&gt; None:\n    \"\"\"Advance task.\"\"\"\n    self.pg.advance(task, advance=advance)\n\n  def __enter__(self) -&gt; Progress:\n    \"\"\"Enter.\"\"\"\n    return self.pg.__enter__()\n\n  def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n  ) -&gt; None:\n    \"\"\"Exit.\"\"\"\n    self.pg.__exit__(exc_type, exc_val, exc_tb)\n\n  def update_res(\n    self, name: str, updates: Mapping[str, float | int | str | None]\n  ) -&gt; None:\n    \"\"\"Update res.\"\"\"\n    if name in self.tasks:\n      self.pg.update(self.tasks[name], res=pformat(updates))\n</code></pre>"},{"location":"api/#nadl.PG.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __enter__(self) -&gt; Progress:\n  \"\"\"Enter.\"\"\"\n  return self.pg.__enter__()\n</code></pre>"},{"location":"api/#nadl.PG.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __exit__(\n  self,\n  exc_type: type[BaseException] | None,\n  exc_val: BaseException | None,\n  exc_tb: TracebackType | None,\n) -&gt; None:\n  \"\"\"Exit.\"\"\"\n  self.pg.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#nadl.PG.add_columns","title":"<code>add_columns(columns)</code>","text":"<p>Add columns.</p> Source code in <code>nadl/loops.py</code> <pre><code>def add_columns(self, columns: tuple[ProgressColumn, ...]) -&gt; Self:\n  \"\"\"Add columns.\"\"\"\n  self.pg.columns += columns\n  return self\n</code></pre>"},{"location":"api/#nadl.PG.add_task","title":"<code>add_task(description, start=True, total=100, completed=0, visible=True, **fileds)</code>","text":"<p>Add task.</p> Source code in <code>nadl/loops.py</code> <pre><code>def add_task(\n  self,\n  description: str,\n  start: bool = True,\n  total: float | None = 100,\n  completed: int = 0,\n  visible: bool = True,\n  **fileds: Any,  # noqa: ANN401\n) -&gt; TaskID:\n  \"\"\"Add task.\"\"\"\n  task = self.pg.add_task(\n    description,\n    start=start,\n    total=total,\n    completed=completed,\n    visible=visible,\n    **fileds,\n  )\n  self.tasks[description] = task\n  return task\n</code></pre>"},{"location":"api/#nadl.PG.advance","title":"<code>advance(task, advance=1)</code>","text":"<p>Advance task.</p> Source code in <code>nadl/loops.py</code> <pre><code>def advance(self, task: TaskID, advance: float = 1) -&gt; None:\n  \"\"\"Advance task.\"\"\"\n  self.pg.advance(task, advance=advance)\n</code></pre>"},{"location":"api/#nadl.PG.init_progress","title":"<code>init_progress(pg=None, console=None, total=True, bar_width=20, extra_columns=(), show_progress=True, theme=None)</code>  <code>classmethod</code>","text":"<p>Init progress bar.</p> Source code in <code>nadl/loops.py</code> <pre><code>@classmethod\ndef init_progress(\n  cls: type[Self],\n  pg: Progress | None = None,\n  console: Console | None = None,\n  total: bool = True,\n  bar_width: int | None = 20,\n  extra_columns: tuple[ProgressColumn, ...] = (),\n  show_progress: bool = True,\n  theme: Theme | None = None,\n) -&gt; Self:\n  \"\"\"Init progress bar.\"\"\"\n  if console is None:\n    console = Console(theme=theme or DEF_LIGHT_THEME)\n  if pg is None:\n    pg = Progress(\n      TextColumn(\n        \"{task.description}\" + \" - {task.completed}/{task.total}\" if total else \"\"\n      ),\n      TimeRemainingColumn(),\n      TimeElapsedColumn(),\n      BarColumn(bar_width),\n      console=console,\n      disable=not show_progress,\n    )\n  pg.columns += extra_columns\n  return cls(pg, console, {})\n</code></pre>"},{"location":"api/#nadl.PG.update_res","title":"<code>update_res(name, updates)</code>","text":"<p>Update res.</p> Source code in <code>nadl/loops.py</code> <pre><code>def update_res(\n  self, name: str, updates: Mapping[str, float | int | str | None]\n) -&gt; None:\n  \"\"\"Update res.\"\"\"\n  if name in self.tasks:\n    self.pg.update(self.tasks[name], res=pformat(updates))\n</code></pre>"},{"location":"api/#nadl.PGThread","title":"<code>PGThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Progress thread.</p> Source code in <code>nadl/loops.py</code> <pre><code>class PGThread(Thread):\n  \"\"\"Progress thread.\"\"\"\n\n  def __init__(self, pg: Progress, task_id: TaskID) -&gt; None:\n    \"\"\"Init.\"\"\"\n    super().__init__()\n    self.pg = pg\n    self.tid = task_id\n    self.done = Event()\n    self.completed = 0\n    self.res: str | None = None\n    super().__init__()\n\n  def run(self) -&gt; None:\n    \"\"\"Run.\"\"\"\n    last_completed = 0\n    wait = self.done.wait\n    while not wait(0.2):\n      if (completed := self.completed) != last_completed:\n        self.pg.advance(self.tid, completed - last_completed)\n        last_completed = completed\n        if self.res is not None:\n          self.pg.update(self.tid, res=self.res)\n          self.res = None\n    self.pg.update(self.tid, completed=self.completed, refresh=True)\n\n  def __enter__(self) -&gt; Self:\n    \"\"\"Enter.\"\"\"\n    self.start()\n    return self\n\n  def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n  ) -&gt; None:\n    \"\"\"Exit.\"\"\"\n    del exc_type, exc_val, exc_tb\n    self.done.set()\n    self.join()\n</code></pre>"},{"location":"api/#nadl.PGThread.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __enter__(self) -&gt; Self:\n  \"\"\"Enter.\"\"\"\n  self.start()\n  return self\n</code></pre>"},{"location":"api/#nadl.PGThread.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __exit__(\n  self,\n  exc_type: type[BaseException] | None,\n  exc_val: BaseException | None,\n  exc_tb: TracebackType | None,\n) -&gt; None:\n  \"\"\"Exit.\"\"\"\n  del exc_type, exc_val, exc_tb\n  self.done.set()\n  self.join()\n</code></pre>"},{"location":"api/#nadl.PGThread.__init__","title":"<code>__init__(pg, task_id)</code>","text":"<p>Init.</p> Source code in <code>nadl/loops.py</code> <pre><code>def __init__(self, pg: Progress, task_id: TaskID) -&gt; None:\n  \"\"\"Init.\"\"\"\n  super().__init__()\n  self.pg = pg\n  self.tid = task_id\n  self.done = Event()\n  self.completed = 0\n  self.res: str | None = None\n  super().__init__()\n</code></pre>"},{"location":"api/#nadl.PGThread.run","title":"<code>run()</code>","text":"<p>Run.</p> Source code in <code>nadl/loops.py</code> <pre><code>def run(self) -&gt; None:\n  \"\"\"Run.\"\"\"\n  last_completed = 0\n  wait = self.done.wait\n  while not wait(0.2):\n    if (completed := self.completed) != last_completed:\n      self.pg.advance(self.tid, completed - last_completed)\n      last_completed = completed\n      if self.res is not None:\n        self.pg.update(self.tid, res=self.res)\n        self.res = None\n  self.pg.update(self.tid, completed=self.completed, refresh=True)\n</code></pre>"},{"location":"api/#nadl.all_array","title":"<code>all_array(x)</code>","text":"<p>All array.</p> Source code in <code>nadl/utils.py</code> <pre><code>def all_array(x: PyTree) -&gt; list[jax.Array]:\n  \"\"\"All array.\"\"\"\n  return jax.tree.leaves(eqx.filter(x, eqx.is_array))\n</code></pre>"},{"location":"api/#nadl.average_precision_score","title":"<code>average_precision_score(labels, preds, average='macro')</code>","text":"<p>Compute PR.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def average_precision_score(\n  labels: Num[Array, \" A\"],\n  preds: Num[Array, \" A\"],\n  average: Literal[\"micro\", \"macro\"] = \"macro\",\n) -&gt; N:\n  \"\"\"Compute PR.\"\"\"\n  return jax.pure_callback(\n    partial(m.average_precision_score, average=average),\n    jax.ShapeDtypeStruct((), jnp.float32),\n    labels,\n    preds,\n  )\n</code></pre>"},{"location":"api/#nadl.classit","title":"<code>classit(x, method='sigmoid', threshold=0.5)</code>","text":"<p>Classify the array.</p> Source code in <code>nadl/utils.py</code> <pre><code>def classit(\n  x: jax.Array,\n  method: Literal[None, \"sigmoid\", \"softmax\", \"threshold\"] = \"sigmoid\",\n  threshold: float = 0.5,\n) -&gt; jax.Array:\n  \"\"\"Classify the array.\"\"\"\n  match method:\n    case \"sigmoid\":\n      return jax.nn.sigmoid(x) &gt; threshold\n    case \"softmax\":\n      x = jax.nn.softmax(x)\n      return jnp.argmax(x, axis=-1, keepdims=True)\n    case \"threshold\":\n      return x &gt; threshold\n    case _:\n      raise ValueError(f\"Unknown method {method}\")\n</code></pre>"},{"location":"api/#nadl.convert","title":"<code>convert(x)</code>","text":"<p>Convert to float.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def convert(x: ArrayLike | N) -&gt; N:\n  \"\"\"Convert to float.\"\"\"\n  if isinstance(x, jax.Array):\n    return x.reshape(-1, *x.shape[1:])\n  return jnp.asarray(x).reshape(-1)\n</code></pre>"},{"location":"api/#nadl.dice_coef","title":"<code>dice_coef(y_true, y_pred, eps=1e-08)</code>","text":"<p>Compute dice coefficient.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def dice_coef(y_true: jax.Array, y_pred: jax.Array, eps: float = 1e-8) -&gt; jax.Array:\n  \"\"\"Compute dice coefficient.\"\"\"\n  y_true = jnp.asarray(y_true)\n  y_pred = jnp.asarray(y_pred)\n\n  intersection = jnp.sum(y_true * y_pred)\n  union = jnp.sum(y_true) + jnp.sum(y_pred)\n\n  return (2.0 * intersection) / (union + eps)\n</code></pre>"},{"location":"api/#nadl.es_loop","title":"<code>es_loop(loader, pg, keys=None, epochs=2, start_epoch=1, prefix='L', es='E', ss='S')</code>","text":"<p>Simple epoch loop.</p> Source code in <code>nadl/data.py</code> <pre><code>def es_loop[T](\n  loader: IdxDataloader[T],\n  pg: PG,\n  keys: Keys | None = None,\n  epochs: int = 2,\n  start_epoch: int = 1,\n  prefix: str = \"L\",\n  es: str = \"E\",\n  ss: str = \"S\",\n) -&gt; Iterator[DState[T]]:\n  \"\"\"Simple epoch loop.\"\"\"\n  es, ss = f\"{prefix}-{es}\", f\"{prefix}-{ss}\"\n  assert epochs &gt; 0, \"Epochs should be greater than 0.\"\n  if keys:\n    keys = jax.vmap(keys.reserve(epochs))\n\n  vdl = eqx.filter_jit(eqx.filter_vmap(loader, axis_size=1))\n  ds: DState[T] = vdl() if keys is None else vdl(keys(jnp.arange(epochs)))\n  ds = tree_at(lambda d: d.name, ds, prefix, is_leaf=lambda x: x is None)\n\n  if es in pg.tasks:\n    pg.pg.reset(pg.tasks[es], total=epochs)\n  else:\n    pg.add_task(es, total=epochs, res=\"\", visible=epochs &gt; 1)\n  pg.advance(pg.tasks[es], start_epoch - 1)\n  if ss in pg.tasks:\n    pg.pg.reset(pg.tasks[ss], total=ds.shape[0] * epochs, res=\"\")\n  else:\n    pg.add_task(ss, total=ds.shape[0] * epochs, res=\"\")\n  pg.advance(pg.tasks[ss], (start_epoch - 1) * ds.shape[0])\n\n  @eqx.filter_jit\n  def _select(i: jax.Array, ii: jax.Array) -&gt; DState[T]:\n    return tree_at(\n      lambda x: (x.epoch, x.step),\n      jax.tree.map(lambda x: x[i, ii] if isinstance(x, jax.Array) else x, ds),\n      (i + 1, i * ds.shape[0] + ii + 1),\n    )\n\n  with PGThread(pg.pg, pg.tasks[ss]) as pts, PGThread(pg.pg, pg.tasks[es]) as pte:\n    for i in jnp.arange(start_epoch - 1, epochs):\n      if epochs &gt; 1:\n        pte.completed += 1\n      for ii in jnp.arange(ds.shape[0]):\n        pts.completed += 1\n        yield _select(i, ii)\n</code></pre>"},{"location":"api/#nadl.filter_concat","title":"<code>filter_concat(xs, filter_spec=eqx.is_array, select_idx=-1)</code>","text":"<p>Filter concat.</p> Source code in <code>nadl/utils.py</code> <pre><code>def filter_concat[T](\n  xs: Sequence[T],\n  filter_spec: Callable[[Any], bool] = eqx.is_array,\n  select_idx: int = -1,\n) -&gt; T:\n  \"\"\"Filter concat.\"\"\"\n  t1, t2 = eqx.partition(xs, filter_spec=filter_spec)\n  t1 = jax.tree.map(lambda *x: jnp.r_[*x], *t1)\n  return eqx.combine(t1, t2[select_idx])\n</code></pre>"},{"location":"api/#nadl.identity_scaler","title":"<code>identity_scaler(arr, axis=0)</code>","text":"<p>Get identity scaler.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def identity_scaler(arr: jax.Array, axis: int = 0) -&gt; SCALER:\n  \"\"\"Get identity scaler.\"\"\"\n  del arr, axis\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    return x\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.iou_coef","title":"<code>iou_coef(y_true, y_pred, eps=1e-08)</code>","text":"<p>Compute intersection over union.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def iou_coef(y_true: jax.Array, y_pred: jax.Array, eps: float = 1e-8) -&gt; jax.Array:\n  \"\"\"Compute intersection over union.\"\"\"\n  y_true = jnp.asarray(y_true)\n  y_pred = jnp.asarray(y_pred)\n\n  intersection = jnp.sum(y_true * y_pred)\n  union = jnp.sum(y_true) + jnp.sum(y_pred) - intersection\n\n  return intersection / (union + eps)\n</code></pre>"},{"location":"api/#nadl.min_max_scaler","title":"<code>min_max_scaler(arr, axis=0)</code>","text":"<p>Get min max scaler.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def min_max_scaler(arr: jax.Array, axis: int = 0) -&gt; SCALER:\n  \"\"\"Get min max scaler.\"\"\"\n  min_, max_ = arr.min(axis=axis, keepdims=True), arr.max(axis=axis, keepdims=True)\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    return (x - min_) / (max_ - min_)\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.normalizer","title":"<code>normalizer(arr, axis=0, norm='l2')</code>","text":"<p>Get normalizer.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def normalizer(\n  arr: jax.Array, axis: int = 0, norm: Literal[\"l1\", \"l2\", \"max\"] = \"l2\"\n) -&gt; SCALER:\n  \"\"\"Get normalizer.\"\"\"\n  match norm:\n    case \"l2\":\n      norm_value = jnp.sqrt(jnp.sum(jnp.square(arr), axis=axis, keepdims=True))\n    case \"l1\":\n      norm_value = jnp.sum(jnp.abs(arr), axis=axis, keepdims=True)\n    case \"max\":\n      norm_value = jnp.max(jnp.abs(arr), axis=axis, keepdims=True)\n    case _:\n      raise ValueError(\"norm should be 'l1', 'l2', or 'max'\")\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    max_val = jnp.maximum(norm_value, jnp.finfo(x.dtype).tiny)  # Avoid division by zero\n    return x / max_val\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.pformat","title":"<code>pformat(xs, short_arrays=False)</code>","text":"<p>Pretty format.</p> Source code in <code>nadl/utils.py</code> <pre><code>def pformat(xs: PyTree, short_arrays: bool = False) -&gt; str:\n  \"\"\"Pretty format.\"\"\"\n  with (console := Console()).capture() as capture:\n    nxs = eqx.tree_pformat(xs, short_arrays=short_arrays)\n    console.print(nxs, soft_wrap=True, justify=\"left\", no_wrap=True, width=40)\n  return capture.get()\n</code></pre>"},{"location":"api/#nadl.pr_auc_score","title":"<code>pr_auc_score(labels, preds)</code>","text":"<p>Compute PR.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def pr_auc_score(labels: Num[Array, \" A\"], preds: Num[Array, \" A\"]) -&gt; N:\n  \"\"\"Compute PR.\"\"\"\n\n  def _callback(lbl: Num[Array, \" A\"], prd: Num[Array, \" A\"]) -&gt; N:\n    precision, recall, _ = m.precision_recall_curve(lbl, prd)\n    return jnp.asarray(m.auc(recall, precision))\n\n  return filter_pure_callback(\n    _callback,\n    labels,\n    preds,\n    result_shape_dtypes=jax.ShapeDtypeStruct((), jnp.float32),\n  )\n</code></pre>"},{"location":"api/#nadl.rle","title":"<code>rle(x, shift=1)</code>","text":"<p>Run length encoding.</p> Source code in <code>nadl/utils.py</code> <pre><code>def rle(x: jax.Array, shift: int = 1) -&gt; str:\n  \"\"\"Run length encoding.\"\"\"\n  return \" \".join(map(str, rle_array(x, shift)))\n</code></pre>"},{"location":"api/#nadl.rle_array","title":"<code>rle_array(x, shift=1)</code>","text":"<p>Run length encoding array.</p> Source code in <code>nadl/utils.py</code> <pre><code>def rle_array(x: jax.Array, shift: int = 1) -&gt; jax.Array:\n  \"\"\"Run length encoding array.\"\"\"\n  x = x.flatten()\n  x = jnp.pad(x, (1, 1), mode=\"constant\")\n  x = jnp.argwhere(x[1:] != x[:-1]).flatten() + shift\n  return x.at[1::2].add(-x[::2])\n</code></pre>"},{"location":"api/#nadl.roc_auc_score","title":"<code>roc_auc_score(labels, preds)</code>","text":"<p>Compute ROC.</p> Source code in <code>nadl/metrics.py</code> <pre><code>def roc_auc_score(labels: Num[Array, \" A\"], preds: Num[Array, \" A\"]) -&gt; N:\n  \"\"\"Compute ROC.\"\"\"\n  return jax.pure_callback(\n    m.roc_auc_score, jax.ShapeDtypeStruct((), jnp.float32), labels, preds\n  )\n</code></pre>"},{"location":"api/#nadl.select_scaler","title":"<code>select_scaler(method='minmax', axis=0)</code>","text":"<p>Get scaler function.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def select_scaler(\n  method: Literal[\"id\", \"minmax\", \"std\", \"l2_norm\", \"l1_norm\", \"max_norm\"] = \"minmax\",\n  axis: int = 0,\n) -&gt; Callable[[jax.Array], SCALER]:\n  \"\"\"Get scaler function.\"\"\"\n  match method:\n    case \"id\":\n      return partial(identity_scaler, axis=axis)\n    case \"minmax\":\n      return partial(min_max_scaler, axis=axis)\n    case \"std\":\n      return partial(standard_scaler, axis=axis)\n    case \"l2_norm\":\n      return partial(normalizer, norm=\"l2\", axis=axis)\n    case \"l1_norm\":\n      return partial(normalizer, norm=\"l1\", axis=axis)\n    case \"max_norm\":\n      return partial(normalizer, norm=\"max\", axis=axis)\n    case _:\n      raise ValueError(f\"Unknown scaler method {method}\")\n</code></pre>"},{"location":"api/#nadl.standard_scaler","title":"<code>standard_scaler(arr, axis=0)</code>","text":"<p>Get standard scaler.</p> Source code in <code>nadl/preprocessing.py</code> <pre><code>def standard_scaler(arr: jax.Array, axis: int = 0) -&gt; SCALER:\n  \"\"\"Get standard scaler.\"\"\"\n  mean, std = arr.mean(axis=axis, keepdims=True), arr.std(axis=axis, keepdims=True)\n\n  def scaler(x: jax.Array) -&gt; jax.Array:\n    \"\"\"Scaler.\"\"\"\n    return (x - mean) / std\n\n  return scaler\n</code></pre>"},{"location":"api/#nadl.state_fn","title":"<code>state_fn(rpath, console=None, keeps=5, clean=False, item_names=None, item_handlers=None, best_fn=None)</code>","text":"<p>Get states manager.</p> Source code in <code>nadl/states.py</code> <pre><code>def state_fn(\n  rpath: Path,\n  console: Console | None = None,\n  keeps: int = 5,\n  clean: bool = False,\n  item_names: tuple[str, ...] | None = None,\n  item_handlers: dict | None = None,\n  best_fn: Callable[[PyTree], float] | None = None,\n) -&gt; tuple[\n  ocp.CheckpointManager,\n  Callable[[int, BaseTrainState, Metric | None, dict[str, float] | None], None],\n]:\n  \"\"\"Get states manager.\"\"\"\n  match (item_names, item_handlers):\n    case (None, None):\n      item_names = (\"state\", \"extra_metadata\")\n      item_handlers = {\n        \"state\": ocp.PyTreeCheckpointHandler(),\n        \"extra_metadata\": ocp.PyTreeCheckpointHandler(),\n      }\n    case _ if item_names and item_handlers:\n      for i in item_names:\n        assert i in item_handlers, f\"Item {i} not in item_handlers.\"\n    case _:\n      raise ValueError(\"item_names and item_handlers should be both None or not None.\")\n\n  if console:\n    console.log(f\"Checkpoint path at {rpath}\")\n  if rpath.exists() and clean:\n    if console:\n      console.log(\"Cleaning up checkpoint...\")\n    shutil.rmtree(rpath)\n\n  mngr = ocp.CheckpointManager(\n    rpath,\n    options=ocp.CheckpointManagerOptions(\n      max_to_keep=keeps, save_interval_steps=1, best_fn=best_fn\n    ),\n    item_names=item_names,\n    item_handlers=item_handlers,\n  )\n\n  def save(\n    step: int,\n    state: BaseTrainState,\n    metadata: Metric | None = None,\n    metrics: dict[str, float] | None = None,\n  ) -&gt; None:\n    \"\"\"Save state.\"\"\"\n    mngr.save(\n      step,\n      args=ocp.args.Composite(\n        state=ocp.args.PyTreeSave(state),  # type: ignore\n        extra_metadata=ocp.args.PyTreeSave(metadata or {}),  # type: ignore\n      ),\n      metrics=metrics or {},\n    )\n\n  return mngr, save\n</code></pre>"}]}